https://en.wikibooks.org/wiki/Java_Programming/Access_Modifiers
Scope


Scope
The scope of a class, a variable or a method is its visibility and its accessibility. The visibility or accessibility means that you can use the item from a given place.
Scope of method parameters
A method parameter is visible inside of the entire method but not visible outside the method.
In code listing 3.14, i is visible within the entire method1 method but not in the method2 and the main methods.
Scope of local variables
A local variable is visible after its declaration until the end of the block in which the local variable has been created.
Access modifiers
You surely would have noticed by now, the words public, protected and private at the beginning of class's method declarations used in this book. These keywords are called the access modifiers in the Java language syntax, and they define the scope of a given item.
For a class
For a variable
For a method
For an interface
The interface methods and interfaces are always public. You do not need to specify the access modifier. It will default to public. For clarity it is considered a good practice to put the public keyword.
The same way all member variables defined in the Interface by default will become static final once inherited in a class.
Summary
The cases in bold are the default.
Utility
A general guideline for visibilities is to only make a member as visible as it needs to be. Don't make a member public if it only needs to be private.
Doing so, you can rewrite a class and change all the private members without making compilation errors, even you don't know all the classes that will use your class as long as you do not change the signature of the public members.
Field encapsulation
Generally, it is best to make data private or protected. Access to the data is controlled by setter and getter methods. This lets the programmer control access to data, allowing him/her to check for and handle invalid data.
In the code section 3.51, the setName() method will only change the value of name if the new name is not null. Because setName() is conditionally changing name, it is wise to return a boolean to let the program know if the change was successful.
Question 3.15: Consider the following class.
List the fields and methods of this class that can be renamed without changing or even knowing the client classes.
Every field or method that is public can be directly called by a client class so this class would return a compile error if the field or the method has a new name.
